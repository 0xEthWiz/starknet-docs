# Cairo 1 Contract Syntax

With the link:https://github.com/starkware-libs/cairo/releases/tag/v2.0.0-rc0[v2.0.0 release] of the Cairo compiler, the contract syntax has evolved.
This affects how external functions, storage, and events are organized inside the contract. We summarize here the technical steps required to migrate from the old syntax
(for a comperhensive treatment of the changes, see the link:https://community.starknet.io/t/cairo-1-contract-syntax-is-evolving/94794[community forum post]).

## How do I migrate

Given a contract written with the previous compiler version (v1.1.0), you can follow the steps below in order to make it compatible with the new syntax:

* Anotate the `Storage` struct with the `#[storage]` attribute

[tabs]
====
old::
+
[source,rust]
----
struct Storage {
    counter: u128,
    other_contract: IOtherContractDispatcher
}
----
new::
+
[source,rust]
----
#[storage]
struct Storage {
    counter: u128,
    other_contract: IOtherContractDispatcher
}
----
====

* Gather your contractâ€™s external/view function signatures under a trait anotated with `#[starknet::interface]`
** Add a generic parameter to the trait, here we use the name `TContractState` as it stands for the state of your contract
** For view functions, add the `self: TContractState` argument
** For external functions, add the `self: @TContractState` argument
** Static functions that do not touch storage or emit events do not require an addition argument

[tabs]
====
old::
+
[source,rust]
----
#[contract]
mod CounterContract {
   #[external]
   fn increase_counter(amount: u128) { ... }
   #[external]
   fn decrease_counter(amount: u128) { ... }
   #[view]
   fn get_counter() -> u128 { ... }
}
----

new::
+
[source,rust]
----
#[starknet::interface]
trait ICounterContract<TContractState> {
   fn increase_counter(ref self: TContractState, amount: u128);
   fn decrease_counter(ref self: TContractState);
   fn get_counter(self: @TContractState) -> u128;
}

#[starknet::contract]
mod CounterContract {
   ...
}
----
====

* Replace the `#[abi]` attribute with `#[starknet::interface]` (while it doesn't affecting the generated code, we recommended adding to the trait a generic parameter `T` representing the contract's state,
and adding the `ref self: T` argument to external functions and `self: @T` argument for view functions)

[tabs]
====
old::
+
[source,rust]
----
#[abi]
trait IOtherContract {
    fn decrease_allowed() -> bool;
}
----
new::
+
[source,rust]
----
#[starknet::interface]
trait IOtherContract<TContractState> {
    fn decrease_allowed(self: @TContractState) -> bool;
}
----
====

* Add the external/view function bodies under an impl of the above trait, and mark the impl with the `[external(v0)]` attribute

[tabs]
====
old::
+
[source,rust]
----
#[contract]
mod CounterContract {
   #[external]
   fn increase_counter(amount: u128) { ... }
   #[external]
   fn decrease_counter(amount: u128) { ... }
   #[view]
   fn get_counter() -> u128 { ... }
}
----

new::
+
[source,rust]
----
#[starknet::interface]
trait ICounterContract<TContractState> {
   fn increase_counter(ref self: TContractState, amount: u128);
   fn decrease_counter(ref self: TContractState);
   fn get_counter(self: @TContractState) -> u128;
}

#[starknet::contract]
mod CounterContract {
   #[external(v0)]
   impl CounterContract of super::ICounterContract<ContractState> {
      fn increase_counter(amount: u128) { ... }
      fn decrease_counter(amount: u128) { ... }
      fn get_counter() -> u128 { ... }
   }
}
----
====

* Modify storage accesses to happen through `ContractState` or `@ContractState` (none external functions in the contract that access storage also need to get it as an argument)

[tabs]
====
old::
+
[source,rust]
----
let current = counter::read();
----
new::
+
[source,rust]
----
let current = self.counter.read();
----
====

* Unify all the contract's events under the `Event` enum, and add a corresponding struct for every variant (all the structs must derive the `Event` trait,
and each member type has to implement the `Serde` trait)

[tabs]
====
old::
+
[source,rust]
----
#[event]
fn counter_increased(amount: u128) {}
#[event]
fn counter_decreased(amount: u128) {}
----
new::
+
[source,rust]
----
#[event]
#[derive(Drop, starknet::Event)]
enum Event {
    CounterIncreased: CounterIncreased,
    CounterDecreased: CounterDecreased
}

#[derive(Drop, starknet::Event)]
struct CounterIncreased {
    amount: u128
}

#[derive(Drop, starknet::Event)]
struct CounterDecreased {
    amount: u128
}
----
====

* Emit events via the `ContractState` type

[tabs]
====
old::
+
[source,rust]
----
fn increase_counter(amount: u128) {
    ...
    counter_increased(amount);
}
----
new::
+
[source,rust]
----
fn increase_counter(amount: u128) {
    ...
    self.emit(Event::CounterIncreased(CounterIncreased { amount }));
}
----
====
